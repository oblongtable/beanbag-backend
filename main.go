package main

import (
	"context"
	"database/sql"
	"embed"
	"log"
	"net/http"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/oblongtable/beanbag-backend/db"
	"github.com/oblongtable/beanbag-backend/initializers"
	"github.com/oblongtable/beanbag-backend/internal/handlers"
	"github.com/oblongtable/beanbag-backend/internal/seed"
	"github.com/oblongtable/beanbag-backend/internal/services"
	"github.com/oblongtable/beanbag-backend/middleware"
	"github.com/oblongtable/beanbag-backend/websocket"

	adaptor "github.com/gwatts/gin-adapter"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	_ "github.com/oblongtable/beanbag-backend/docs" // docs is generated by Swag CLI, you have to import it.
)

// @title Beanbag Backend API
// @version 1.0
// @description This is the API for the Beanbag Backend quiz application.

// @host localhost:8080
// @BasePath /
// @schemes http
// @query.collection.format multi
var (
	server    *gin.Engine
	DBQueries *db.Queries
	db_conn   *sql.DB
	//go:embed migrations/*.sql
	embedMigrations embed.FS
)

func init() {
	err := initializers.LoadConfig(".")
	if err != nil {
		log.Fatal("? Could not load environment variables", err)
	}

	// Connect to the database
	dbConn, err := initializers.NewDBConnection(initializers.GetConfig())
	if err != nil {
		log.Fatal("? Could not connect to the database", err)
	}

	// Run migrations
	initializers.MigrateDB(dbConn, embedMigrations)

	// Create a new Queries instance
	queries := db.New(dbConn)

	// Make the connection object available globally
	db_conn = dbConn

	// Make the queries available globally
	DBQueries = queries

	// --- Run Seeding ---
	seedCtx := context.Background()
	// Pass both db_conn and DBQueries to NewSeedData
	seeder := seed.NewSeedData(db_conn, DBQueries)
	if err := seeder.SeedDatabaseIfNeeded(seedCtx); err != nil {
		log.Printf("! Database seeding failed: %v\n", err)
	}
	// --- Seeding Done ---

	server = gin.Default()
}

func main() {
	config := initializers.GetConfig()
	wssvr := websocket.NewWebSockServer()

	// Initialize services
	quizService := services.NewQuizService(db_conn, DBQueries)
	userService := services.NewUserService(DBQueries)
	questionService := services.NewQuestionService(DBQueries)
	answerService := services.NewAnswerService(DBQueries)

	// Initialize handlers
	quizHandler := handlers.NewQuizHandler(quizService)
	userHandler := handlers.NewUserHandler(userService)
	questionHandler := handlers.NewQuestionHandler(questionService)
	answerHandler := handlers.NewAnswerHandler(answerService)

	server.Use(cors.New(cors.Config{
		AllowOrigins:     []string{config.ClientOrigin},
		AllowMethods:     []string{"GET", "PUT", "POST", "PATCH"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	router := server.Group("/")
	router.GET("/", func(ctx *gin.Context) {
		message := "Welcome to Golang api with SQLC, Goose and Postgres"
		ctx.JSON(http.StatusOK, gin.H{"status": "success", "message": message})
	})

	router.GET("/db_health", func(ctx *gin.Context) {
		var tm time.Time

		// Use DBQueries.db.QueryRowContext() to execute the raw SQL query
		ctxTimeout, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		err := db_conn.QueryRowContext(ctxTimeout, "SELECT NOW()").Scan(&tm)
		if err != nil {
			log.Printf("Query failed: %v\n", err)
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get database time"})
			return
		}

		ctx.JSON(http.StatusOK, gin.H{
			"api":               "golang",
			"now_from_postgres": tm,
		})
	})

	router.GET("/ping", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, "pong")
	})

	// WebSocket route
	router.GET("/ws", wssvr.ServeWs)

	// API routes
	api := router.Group("/api")
	{
		api.Use(adaptor.Wrap(middleware.VerifyToken()))
		api.Use(middleware.ExtractAndSetClaims())

		// User routes
		api.POST("/users", userHandler.CreateUser)
		api.POST("/users/sync", userHandler.SyncUser)
		api.GET("/users/:id", userHandler.GetUser)

		// Quiz routes
		api.POST("/quizzes", quizHandler.CreateQuiz)
		api.POST("/quizzes/minimal", quizHandler.CreateQuizMinimal) // Assuming this maps to full creation
		api.GET("/quizzes/:id", quizHandler.GetQuiz)
		api.GET("/quizzes/:id/full", quizHandler.GetFullQuiz) // Add this route for the full quiz

		// Question routes
		api.POST("/questions", questionHandler.CreateQuestion)
		api.GET("/questions/:id", questionHandler.GetQuestion)

		// Answer routes
		api.POST("/answers", answerHandler.CreateAnswer)
		api.GET("/answers/:id", answerHandler.GetAnswer)

	}

	// Swagger route
	url := ginSwagger.URL("http://localhost:8080/swagger/doc.json") // The url pointing to API definition
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, url))

	log.Fatal(server.Run(":" + config.ServerPort))
}
